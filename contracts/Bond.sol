// (c) Kallol Borah, 2020
// Implementation of the Via zero coupon bond.

pragma solidity >=0.5.0 <0.7.0;

import "./erc/ERC20.sol";
import "./oraclize/ViaRate.sol";
import "./utilities/DayCountConventions.sol";
import "./utilities/SafeMath.sol";
import "./utilities/StringUtils.sol";
import "@openzeppelin/upgrades/contracts/Initializable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./utilities/Strings.sol";

contract Bond is ERC20, Initializable, Ownable {

    using strings for *;

    //via token factory address
    Factory owner;

    //name of Via token (eg, Via-USD%)
    bytes32 public name;
    bytes32 public symbol;

    uint256 viaBondPrice;
    uint256 faceValue;
    uint256 redemptionAmount;
    int256 balanceTenure;

    struct cash{
        bytes32 name;
        uint256 balance;
    }

    //cash balances held by this issuer against which via bond tokens are issued
    mapping(address => cash) private cashbalances;

    //a Via bond has some value, corresponds to a fiat currency
    //has a borrower and lender that have agreed to a zero coupon rate which is the start price of the bond
    //and a tenure in unix timestamps of seconds counted from 1970-01-01. Via bonds are of one year tenure.
    //constructor for creating Via bond
    struct loan{
        address borrower;
        bytes32 currency;
        uint256 faceValue;
        uint256 price;
        uint256 collateralAmount;
        bytes32 collateralCurrency;
        uint256 timeOfIssue;
        uint tenure; 
    }

    mapping(address => loan) public loans;

    //events to capture and report to Via oracle
    event ViaBondIssued(bytes32 currency, uint value, uint price, uint tenure);
    event ViaBondRedeemed(bytes32 currency, uint value, uint price, uint tenure);

    //initiliaze proxies
    function initialize(bytes32 memory _name, address _owner) public {
        Ownable.initialize(_owner);
        owner = Factory(_owner);
        name = _name;
        symbol = _name;
    }    

    //handling pay in of ether for issue of via bond tokens
    receive() payable public{
        //ether paid in
        require(msg.value !=0);
        //issue via bond tokens
        issue(msg.value, msg.sender, "ether");
    }

    //overriding this function of ERC20 standard
    function transferFrom(address sender, address receiver, uint256 tokens) override public returns (bool){
        //owner should have more tokens than being transferred
        require(tokens <= balances[sender]);
        //sending contract should be allowed by token owner to make this transfer
        require(tokens <= allowed[sender][msg.sender]);
        //check if tokens are being transferred to this bond contract
        if(receiver == address(this)){ 
            //if token name is the same, this transfer has to be redeemed
            if(address(msg.sender).name()==name){ 
                if(redeem(tokens, receiver))
                    return true;
                else
                    return false;
            }
            //else request issue of bond tokens generated by this contract
            else{
                //issue only if paid in tokens are cash tokens, since bond tokens can't be paid to issue bond token
                for(uint256 p=0; p<owner.tokens.length; p++){
                    if(owner.tokens[p].name == address(msg.sender).name() &&
                        owner.tokens[p].tokenType != "ViaBond"){
                        issue(tokens, receiver, address(msg.sender).name());
                        return true;
                    }
                }
                return false;
            }
        } 
        else { 
            //tokens are being sent to a user account
            balances[sender] = balances[sender].sub(tokens);
            allowed[sender][msg.sender] = allowed[sender][msg.sender].sub(tokens);
            balances[receiver] = balances[receiver].add(tokens);
            emit Transfer(sender, receiver, tokens);
            return true;
        }                
    }

    //requesting issue of Via bonds to borrower for amount of paid in currency as collateral
    function issue(uint256 amount, address borrower, bytes32 currency) private {
        //ensure that brought amount is not zero
        require(amount != 0);
        bool found = false;
        //adds paid in currency to this contract's cash balance
        for(uint256 p=0; p<cashbalances[address(this)].length; p++){
            if(cashbalances[address(this)][p].name == currency){
                cashbalances[address(this)][p].amount += amount;
                found = true;
            }
        }
        if(!found){
            cashbalances[address(this)][p].name = currency;
            cashbalances[address(this)][p].amount = amount;
        }
        //find face value of bond in via denomination
        faceValue = convertToVia(amount, currency);
        //find price of via bonds to transfer after applying exchange rate
        viaBondPrice = getBondValueToIssue(faceValue, currency, 1);
        //add via bonds to this contract's balance first
        balances[address(this)].add(viaBondPrice); 
        //transfer amount from issuer/sender to borrower 
        transfer(borrower, viaBondPrice);
        //adjust total supply
        totalSupply_ += viaBondPrice;
        //keep track of issues
        storeIssuedBond(borrower, name, faceValue, viaBondPrice, amount, currency, now, 1);
        //generate event
        emit ViaBondIssued(name, amount, viaBondPrice, 1);
    }

    //requesting redemption of Via bonds and transfer of ether or via cash collateral to borrower 
    //to do : redemption of Via bonds for fiat currency
    function redeem(uint256 amount, address borrower) private returns(bool){
        //ensure that sold amount is not zero
        require(amount != 0);
        //find currency that borrower had deposited earlier
        bool found = false;
        bytes32 name;
        for(uint256 p=0; p<loans[address(this)].length; p++){
            if(loans[address(this)][p].borrower == borrower){
                name = loans[address(this)][p].currency;
                found = true;
            }
        }
        if(found){
            found = false;
            //find redemption amount to transfer 
            var(redemptionAmount, balanceTenure) = getBondValueToRedeem(amount, name, borrower);
            //only if the issuer's balance of the deposited currency is more than or equal to amount redeemed
            for(uint256 p=0; p<cashbalances[address(this)].length; p++){
                //check if currency in which redemption is to be done is available in cash balances
                if(cashbalances[address(this)][p].name == name){
                    //check if currency in which redemption is to be done has sufficient balance
                    if(cashbalances[address(this)][p].balance > redemptionAmount){
                        //deduct amount to be transferred from cash balance
                        cashbalances[address(this)][p].balance -= redemptionAmount;
                        //transfer amount from issuer/sender to borrower 
                        transfer(borrower, redemptionAmount);
                        //adjust total supply
                        totalSupply_ =- amount;
                        //generate event
                        emit ViaBondRedeemed(name, amount, redemptionAmount, balanceTenure);
                        return true;
                    }
                }
            }
            if(!found)
                return false;
        }
        return false;
    }

    //uses Oraclize to find Via face value of amount passed in currency
    function convertToVia(uint256 amount, bytes32 currency) private returns(uint256){
        if(currency=="ether"){
            //to first convert amount of ether passed to this function to USD
            uint256 amountInUSD = (amount/1000000000000000000)*uint256(stringToUint(new EthToUSD()));
            //to then convert USD to Via-currency if currency is not USD itself 
            if(name!="Via-USD"){
                uint256 inVia = amountInUSD * uint256(stringToUint(new ViaRate("Via_USD_to_".toSlice().concat(name.toSlice()), "er")));
                return inVia;
            }
            else{
                return amountInUSD;
            }
        }
        //if currency paid in another via currency
        else{
            uint256 inVia = uint256(stringToUint(new ViaRate(currency.toSlice().concat("_to_".toSlice().concat(name.toSlice())),"er")));
            return inVia;
        }
    }

    //convert Via-currency (eg, Via-EUR, Via-INR, Via-USD) to Ether or another Via currency
    function convertFromVia(uint256 amount, bytes32 currency) private returns(uint256){
        //if currency to convert from is ether
        if(currency=="ether"){
            uint256 amountInViaUSD = amount * uint256(stringToUint(new ViaRate(name.toSlice().concat("_to_Via_USD".toSlice()),"er")));
            uint256 inEth = amountInViaUSD * (1/uint256(stringToUint(new EthToUSD())));
            return inEth;
        }
        //else convert to another via currency
        else{
            return(uint256(stringToUint(new ViaRate(name.toSlice().concat("_to_".toSlice().concat(currency.toSlice())),"er")))*amount);
        }
    }

    //uses Oraclize to calculate price of 1 year zero coupon bond in currency and for amount to issue to borrower
    //to do : we need to support bonds with tenure different than the default 1 year. 
    function getBondValueToIssue(uint256 amount, bytes32 currency, uint tenure) private returns(uint256){
        //to first convert amount of ether passed to this function to USD
        uint256 amountInUSD = (amount/1000000000000000000)*uint256(stringToUint(new EthToUSD()));
        //to then get Via interest rates from oracle and calculate zero coupon bond price
        if(currency!="Via-USD"){
            return amountInUSD / (1 + uint256(stringToUint(new ViaRate("Via_USD_to_".toSlice().concat(currency.toSlice()), "ir")))) ^ tenure;
        }
        else{
            return amountInUSD / (1 + uint256(stringToUint(new ViaRate("USD", "ir")))) ^ tenure;
        }
    }

    //calculate price of redeeming zero coupon bond in currency and for amount to borrower who may redeem before end of year
    function getBondValueToRedeem(uint256 _amount, bytes32 _currency, address _borrower) private returns(uint256, uint){
        //find out if bond is present in list of issued bonds
        uint256 toRedeem;
        for(uint p=0; p < loans[msg.sender][p].length; p++){
            //if bond is found to be issued
            if(loans[msg.sender][p].borrower == _borrower && 
                loans[msg.sender][p].currency == _currency &&
                loans[msg.sender][p].price >= amount){
                    uint256 timeOfIssue = loans[msg.sender][p].timeOfIssue;
                    //if entire amount is to be redeemed, remove issued bond from store
                    if(loans[msg.sender][p].price - amount ==0){
                        toRedeem = amount;
                        delete(loans[msg.sender][p]);
                    }else{
                        //else, reduce outstanding value of bond
                        loans[msg.sender][p].price = loans[msg.sender][p].price - amount;
                    }
                    return(convertFromVia(toRedeem, _currency), DayCountConventions.diffTime(now, timeOfIssue));
            }
        }
        return(0,0);
    }

    function storeIssuedBond(address _borrower, 
                            bytes32 _currency, 
                            uint256 _facevalue, 
                            uint256 _viabond, 
                            uint256 _amount, 
                            bytes32 _collateralCurrency, 
                            uint _timeofissue, 
                            uint _tenure) private {
        loans[msg.sender][loans.length].borrower = _borrower;
        loans[msg.sender][loans.length].currency = _currency;
        loans[msg.sender][loans.length].faceValue = _facevalue;
        loans[msg.sender][loans.length].price = _viabond;
        loans[msg.sender][loans.length].collateralAmount = _amount;
        loans[msg.sender][loans.length].collateralCurrency = _collateralCurrency; //to do : we need to support fiat and Via currencies too
        loans[msg.sender][loans.length].timeOfIssue = _timeofissue;
        loans[msg.sender][loans.length].tenure = _tenure; //to do : we need to support different tenures also
    }

}
